/*
Model name: alternation of generations (nucleotide-enabled)

1 April 2020
Authors: Ding He, Ben Haller

Model description:
This model simulates diploid individuals and haploid gametes alternately, representing alternation of generations of sexual reproduction in animals (but may be extending to other organisms). The recombination is controlled within the script, not relied on SLiM default engine. The diploid adults are kepted in one subpop (p1) and haploid gametes in another (p2). This setup enables a easy way to introduce non-neutral mutations (selection) in a variety of ways at diploid/haploid level.

Although this is a non-Wright-Fisher (nonWF) model, we constrain strick non-overlapping generations and keep the diploid population p1 size stable (fluctuating around the population carrying capacity) for simplicity. This could be modified later if more realistic/complex scenarios are desired.

"M" represents male/sperm and "F" female/egg, which could be removed for a model of hermaphroditic gametes. The sex ratio at diploid level is now ~ 1:1.

The code for nucleotide: A=0, C=1, G=2, T=3

The main output of the model is records of males and sperms. Each line represents one male or sperm. The spec of the line is:

For male:
M|Tag#|Sim_gen#|Diploid genone 1 or 2|Breakpoint positions|(B)enficial/(D)eleterious mutation positions or Neu|All mutation (SNP) positions|Nucleotide code string of all mutations (SNPs)
For sperm:
S|Tag#|Sim_gen#|Haploid genome tetrad 1/2/3/4|Breakpoint positions|# of breakpoint|(B)enficial/(D)eleterious mutation positions or Neu|All mutation (SNP) positions|Nucleotide code string of all mutations (SNPs)

Examples:
1. Male (tag 1) genome1 without beneficial/deleterious mutation: 
M|1|20000|1|0|B 19620|13094 16436 18118 18599 18681 19593 19620...|0 2 0 1 1 3 2...
2. Sperm (tag 1) tetrad genome1 without beneficial/deleterious mutation:	
S|1|20000|1|248870|1|Neu|159 1196 4355 5695 6304 20780...|0 2 0 1 1 2...

Although the records are stored in order of Male-within_ejaculate_sperms batches, all individuals of the founding population  (p1) are uniquely tagged and all sperms inherit tags from their father, and all offsprings (diploid) inherit tags of their fertilized-sperms. In other words, the tags track the paternal pedigree. Since we are storing every male and every sperm for a desired number of generations, the size of output data depends on founding population size, genome length, number of times of meosis (which dertermines how many sperms) and the number of generations stored.

[Controlable genetic mechanisms]
1. Recombination.
Currently, the recombination during the burn-in phase and alternation phase is both SLiM-controlled via only the recombination rate (R). Apparently we could add more complex (realistic) recombination maps to govern the recombination further.
2. Genomic element structure.
Currently, the model holds the simplist structure (no structure just a long stretch of seq). Apparently we could add more complex (realistic) structures (genes, intron-exon, non-coding regions...etc).

Most of the simulating parameters can be passed via the commandline:

k, carrying capacity (diploid) / founding population size
MU, mutation rate
R, recombination rate
L, chromosome length
out_file, output file path and name
mc, meiosis count per diploid individual
ST, selection type: (b)enefiical, (d)eleterious, (n)eutral
SC, non-neutral selection scenario: (h)aploid-only, (d)iploid-only, (b)oth, (n)eutral

*/

// Given two haploid genomes, the number of segregating sites between the two, divided by the length of the chromosome, is pi, the average nucleotide heterozygosity, which is the standard measure for the genetic diversity in a population.  The expected value of pi is 4*Ne*mu for a pure neutral model.
function (f$)genomicHeterozygosity(o<Genome>$ genome1, o<Genome>$ genome2, i$ chrLen)
{
	muts1 = genome1.mutations;
	muts2 = genome2.mutations;
	unshared = setSymmetricDifference(muts1, muts2);
	pi = size(unshared) / chrLen;
	return pi;
}

// Estimate the average nucleotide heterozygosity in a subpopulation by sampling individuals at random and averaging the heterozygosity of all of the individuals sampled.  Note that this function normally uses a sample of individuals, of a size supplied in the optional parameter sampleSize; but if sampleSize is equal to the number of individuals in subpop, it will instead compute the heterozygosity exactly, as the mean of the heterozygosities of all individuals, rather than taking a sample. 
function (f$)subpopHeterozygosity(o<Subpopulation>$ subpop, i$ sampleSize)
{
	if (sampleSize == subpop.individualCount)
		sampledIndividuals = subpop.individuals;
	else
		sampledIndividuals = sample(subpop.individuals, sampleSize, replace=T);
	
	pi_total = 0;
	for (individual in sampledIndividuals)
	{
		genomes = individual.genomes;
		individual_pi = genomicHeterozygosity(genomes[0], genomes[1], L);
		pi_total = pi_total + individual_pi;
	}
	return pi_total / sampleSize;
}
initialize()
{	
	// turn on nonWF model	
	initializeSLiMModelType("nonWF");

	// turn on nucleotide simulation mode, and potential speed-up with mutationRuns=16
	initializeSLiMOptions(mutationRuns=16, nucleotideBased=T);

	if (exists("slimgui"))
	{
		defineConstant("K", 500);     // carrying capacity (diploid)
		defineConstant("MU", 1e-7);   // mutation rate
		defineConstant("R", 1e-8);    // recombination rate
		defineConstant("L", initializeAncestralNucleotides("~/Desktop/tmp/D_rerio_ch25_excl_N_1MB.split.10Kmer.fasta"));  // ancestral seq from a fasta file
		defineConstant("out_file", "~/Desktop/tmp/slimout");	// output file name
		defineConstant("mc", 250);		// meiosis count per diploid individual
		defineConstant("ST", "n");	// selection type: (b)enefiical, (d)eleterious, (n)eutral
		defineConstant("SC", "n");	// non-neutral selection scenario: (h)aploid-only, (d)iploid-only, (b)oth, (n)eutral
		defineConstant("BP", "s");	// "n": no crossing-over; (Integer>0) user-defined numbers of crossing-over; "s": numbers of crossing-over based on recombination rate
		defineConstant("GS", F);    // does the chromosome have genomic structures? True/False 		
		defineConstant("NonCodingLen", 5000);    // Noncoding region length 		
		defineConstant("IntronLen", 500);    // Intron region length 		
		defineConstant("ExonLen", 300);    // Exon region length 		
		defineConstant("SpermPopSeqFastaCount", 1);    // The number within-ejaculate sperm pop per generation will be output as genome fasta file
		defineConstant("GrandOutput", F);    // Write the big final output or not?
	} else {
		if (!exists("in_file")) defineConstant("in_file", "~/Desktop/tmp/D_rerio_ch25_excl_N_1MB.split.10Kmer.fasta");	// input file name: ancestral seq from a fasta file
		defineConstant("L", initializeAncestralNucleotides(in_file));  // genome length
		if (!exists("out_file")) defineConstant("out_file", "~/Desktop/tmp/slimout");	// output file name
		if (!exists("K")) defineConstant("K", 500);
		if (!exists("mc")) defineConstant("mc", 250);
		if (!exists("MU")) defineConstant("MU", 1e-7);
		if (!exists("R")) defineConstant("R", 1e-8);
		if (!exists("ST")) defineConstant("ST", "n");
		if (!exists("SC")) defineConstant("SC", "n");
		if (!exists("BP")) defineConstant("BP", "s");
		if (!exists("GS")) defineConstant("GS", F);
		if (!exists("NonCodingLen")) defineConstant("NonCodingLen", 5000);
		if (!exists("IntronLen")) defineConstant("IntronLen", 500);
		if (!exists("ExonLen")) defineConstant("ExonLen", 300);
		if (!exists("SpermPopSeqFastaCount")) defineConstant("SpermPopSeqFastaCount", 1);
		if (!exists("GrandOutput")) defineConstant("GrandOutput", F);
	}
	
	// nucleotide interchangability matrix
	// note that the global mutation rate will be 3*MU due to nucleotide interchangability matrix 
	mm = mmJukesCantor(MU);

	// specify modeling of autosome
	initializeSex("A");
	
	// first set up neutral mutation type
	initializeMutationTypeNuc("m1", 0.5, "f", 0.0);		// neutral
	m1.convertToSubstitution = T;
	
	// set up selection scenarios
	if (ST == "b") {
		catn("***Selection after burn-in: beneficial***");
		initializeMutationTypeNuc("m2", 1.0, "f", 1.0);		// full dominant (h=1.0) beneficial (s=0.5)
		m2.convertToSubstitution = T;
	} else if (ST == "d") {
		catn("***Selection after burn-in: deleterious***");
		initializeMutationTypeNuc("m2", 1.0, "f", -0.5);	// full dominant (h=1.0) deleterious (s=-0.5)
		m2.convertToSubstitution = T;
	} else {
		catn("***Selection after burn-in: neutral***");
		initializeMutationTypeNuc("m2", 0.5, "f", 0.0);		// this neutral mutation type won't be used, just for the coding convenience and to avoid error messages
		m2.convertToSubstitution = T;
	}

	// if wish, set up genomic structures
	if (GS)
	{
		// set up other mutation types
		initializeMutationTypeNuc("m3", 0.5, "f", 0.0);         // synonymous
		m3.convertToSubstitution = T;
		initializeMutationTypeNuc("m4", 0.1, "g", -0.03, 0.2);  // deleterious
		m4.convertToSubstitution = T;
		initializeMutationTypeNuc("m5", 0.8, "e", 0.1);         // beneficial
		m5.convertToSubstitution = T;
	
		initializeGenomicElementType("g1", c(m3,m4,m5), c(2,8,0.1), mm);  // exon; often suffer deleterious mutations, sometimes get neutral (synonymous) mutations, and very rarely get beneficial mutations
		g1.color = "blue";
	
		initializeGenomicElementType("g2", c(m1,m4), c(9,1), mm);       // intron; often get neutral (non-coding) mutations, and occasionally get deleterious mutations
		g2.color = "lightblue";
		initializeGenomicElementType("g3", m1, 1, mm);           // non-coding; neutral (non-coding) mutations only
		g3.color = "black";

		base = 0;
	
		while (base < L-5001) 
		{
			// start a gene structure
			// make the 1st non-coding region of a fixed 5000 bp length
			initializeGenomicElement(g3, base, base + NonCodingLen - 1);
			base = base + NonCodingLen;
		
			// make the 1st (fixed length) exon
			initializeGenomicElement(g1, base, base + ExonLen - 1);
			base = base + ExonLen;
			
			// make additional intron-exon pairs a fix of 5-5
			for (k in 1:5)
			{
				initializeGenomicElement(g2, base, base + IntronLen - 1);
				base = base + IntronLen;
			
				initializeGenomicElement(g1, base, base + ExonLen - 1);
				base = base + ExonLen;
			}			
		}		
		// final non-coding region
		initializeGenomicElement(g3, base, L - 1);
	}
	else 
	{
		initializeGenomicElementType("g1", m1, 1.0, mm);
		initializeGenomicElement(g1, 0, L-1);
	}
	initializeRecombinationRate(R);	
}
// generations 1-19999 are burn-in phase1:19999 reproduction(p1){	// generate K offspring with randomly chosen parents	for (i in seqLen(K))	{		Father = subpop.sampleIndividuals(1, sex="M");		Mother = subpop.sampleIndividuals(1, sex="F");		child = subpop.addCrossed(Mother, Father);	}		// done generating all offsprings, don't call us again this generation	self.active = 0;}1 early(){	catn("*****Burn-in is starting*****\n");
	defineConstant("simID", getSeed());
	sim.setValue("counter", 3);				// within-ejaculate sperms population counter	sim.addSubpop("p1", K);		// diploid population	sim.addSubpop("p2", 0);		// haploid population
}1:19999 early(){	// non-overlapping generations	inds = p1.individuals;	adults = inds[inds.age > 0];	adults.fitnessScaling = 0.0;
	
	// report generation progress
	if (sim.generation % 1000 == 0) catn("gen: " + sim.generation);}19999 late(){				// all males get a non-zero unique tag value
	males = p1.subsetIndividuals(sex="M");	males.tag = 1:males.length();
			catn("*****Burn-in is completed*****\n");
	// within-ejaculate sperms populations
	for (n in 3:(males.length()+2)) { sim.addSubpop("p"+n, 0); }}20000:20009 reproduction(p1){	// The ind record line: Male or Sperm|Tag|Sim_gen|Male genone1 or genone2; Sperm 1-4|Breakpoints|(B)enficial
	// mut/(D)eleterious mut positions|All mut positions
	g_1 = genome1;
	g_1_mut_value = paste(g_1.mutations.nucleotideValue);
	g_1_mut_pos = paste(g_1.mutations.position);
	
	if (ST == "b") { g_1_nonNeu_mut_pos = paste(c("B", g_1.positionsOfMutationsOfType(m2))); }
	else if (ST == "d") { g_1_nonNeu_mut_pos = paste(c("D", g_1.positionsOfMutationsOfType(m2))); }
	else { g_1_nonNeu_mut_pos = "Neu"; }
		g_2 = genome2;
	g_2_mut_value = paste(g_2.mutations.nucleotideValue);
	g_2_mut_pos = paste(g_2.mutations.position);
	
	if (ST == "b") { g_2_nonNeu_mut_pos = paste(c("B", g_2.positionsOfMutationsOfType(m2))); }
	else if (ST == "d") { g_2_nonNeu_mut_pos = paste(c("D", g_2.positionsOfMutationsOfType(m2))); }
	else { g_2_nonNeu_mut_pos = "Neu"; }
	
	n = sim.getValue("counter");
	pn = sim.subpopulations[sim.subpopulations.id == n];
	
	if (GrandOutput)
	{
		if (individual.sex == "M")
		{
			male_g1_record = paste(c("M", individual.tag, sim.generation, "1", "0", g_1_nonNeu_mut_pos, g_1_mut_pos, g_1_mut_value), sep = "|");
			writeFile(out_file+"_"+simID, male_g1_record, append = T);
			male_g2_record = paste(c("M", individual.tag, sim.generation, "2", "0", g_2_nonNeu_mut_pos, g_2_mut_pos, g_2_mut_value), sep = "|");
			writeFile(out_file+"_"+simID, male_g2_record, append = T);
		}
	}
		for (meiosisCount in 1:mc)	{		if (individual.sex == "M")		{			if (BP == "s") { breaks = sim.chromosome.drawBreakpoints(individual); }
			else if (BP == "n") { breaks = sim.chromosome.drawBreakpoints(individual, n = 0); }
			else { breaks = sim.chromosome.drawBreakpoints(individual, n = BP); }
			
			s_1 = p2.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "M");
			pn.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "M");
			s_2 = p2.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "M");
			pn.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "M");
			
			s_1_mut_value = paste(s_1.genome1.mutations.nucleotideValue);
			s_1_mut_pos = paste(s_1.genome1.mutations.position);
			if (ST == "b") { s_1_nonNeu_mut_pos = paste(c("B", s_1.genome1.positionsOfMutationsOfType(m2))); }
			else if (ST == "d") { s_1_nonNeu_mut_pos = paste(c("D", s_1.genome1.positionsOfMutationsOfType(m2))); }
			else { s_1_nonNeu_mut_pos = "Neu"; }

			s_2_mut_value = paste(s_2.genome1.mutations.nucleotideValue);
			s_2_mut_pos = paste(s_2.genome1.mutations.position);
			if (ST == "b") { s_2_nonNeu_mut_pos = paste(c("B", s_2.genome1.positionsOfMutationsOfType(m2))); }
			else if (ST == "d") { s_2_nonNeu_mut_pos = paste(c("D", s_2.genome1.positionsOfMutationsOfType(m2))); }
			else { s_2_nonNeu_mut_pos = "Neu"; }

			break_num = size(breaks);
			if (break_num==0) { breaks = 0; }
			else if (break_num>1) { breaks = paste(breaks, sep = "_"); }
			if (GrandOutput)
			{				s1_record = paste(c("S", individual.tag, sim.generation, "1", breaks, break_num, s_1_nonNeu_mut_pos, s_1_mut_pos, s_1_mut_value), sep = "|");
				writeFile(out_file+"_"+simID, s1_record, append = T);
				s2_record = paste(c("S", individual.tag, sim.generation, "2", breaks, break_num, s_2_nonNeu_mut_pos, s_2_mut_pos, s_2_mut_value), sep = "|");
				writeFile(out_file+"_"+simID, s2_record, append = T);
			}
						if (BP == "s") { breaks = sim.chromosome.drawBreakpoints(individual); }
			else if (BP == "n") { breaks = sim.chromosome.drawBreakpoints(individual, n = 0); }
			else { breaks = sim.chromosome.drawBreakpoints(individual, n = BP); }

			s_3 = p2.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "M");
			pn.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "M");			s_4 = p2.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "M");
			pn.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "M");
			
			s_3_mut_value = paste(s_3.genome1.mutations.nucleotideValue);
			s_3_mut_pos = paste(s_3.genome1.mutations.position);
			if (ST == "b") { s_3_nonNeu_mut_pos = paste(c("B", s_3.genome1.positionsOfMutationsOfType(m2))); }
			else if (ST == "d") { s_3_nonNeu_mut_pos = paste(c("D", s_3.genome1.positionsOfMutationsOfType(m2))); }
			else { s_3_nonNeu_mut_pos = "Neu"; }

			s_4_mut_value = paste(s_4.genome1.mutations.nucleotideValue);
			s_4_mut_pos = paste(s_4.genome1.mutations.position);
			if (ST == "b") { s_4_nonNeu_mut_pos = paste(c("B", s_4.genome1.positionsOfMutationsOfType(m2))); }
			else if (ST == "d") { s_4_nonNeu_mut_pos = paste(c("D", s_4.genome1.positionsOfMutationsOfType(m2))); }
			else { s_4_nonNeu_mut_pos = "Neu"; }

			break_num = size(breaks);
			if (break_num==0) { breaks = 0; }
			else if (break_num>1) { breaks = paste(breaks, sep = "_"); }
			if (GrandOutput)
			{
				s3_record = paste(c("S", individual.tag, sim.generation, "3", breaks, break_num, s_3_nonNeu_mut_pos, s_3_mut_pos, s_3_mut_value), sep = "|");
				writeFile(out_file+"_"+simID, s3_record, append = T);
				s4_record = paste(c("S", individual.tag, sim.generation, "4", breaks, break_num, s_4_nonNeu_mut_pos, s_4_mut_pos, s_4_mut_value), sep = "|");
				writeFile(out_file+"_"+simID, s4_record, append = T);
			}
			// within-ejaculate sperms inherit the tag from their father			c(s_1, s_2, s_3, s_4).tag = individual.tag;
		}		else if (individual.sex == "F")		{			breaks = sim.chromosome.drawBreakpoints(individual);			if (runif(1) <= 0.5)
			{				e = p2.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "F");
			}			else
			{				e = p2.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "F");
			}		}	}
	if (individual.sex == "M") 
	{
		sim.setValue("counter", n + 1);
		pn.tag = individual.tag;
	}}20000:20009 reproduction(p2, "F"){	// initially, all sperms will have inherited tags of 1:pop_size; we will switch them to 0	// when they get used to fertilize an egg, so that they are only used once
	// We also need to increase mating success for the fitter sperms
	sperms = p2.subsetIndividuals(sex="M");	do { mate = sample(sperms, 1, weights=sperms.fitnessScaling); } while (mate.tag == 0);	// the offspring is tagged inherited from the paternal lineage
	child = p1.addRecombinant(individual.genome1, NULL, NULL, mate.genome1, NULL, NULL);	child.tag = mate.tag;	
	// tag 0 for used sperms	mate.tag = 0;}// Note that the addition of non-neutral mutations in nonWF model does not affect the mating success and fecundity
// and it actually will not have any desired effect in the current model because all individuals will be erased 
// regardless fitness for strict non-overlapping generations. In this sense, are non-neutral mutations still desired?  20000:20009 early(){	if (sim.generation % 2 == 0)	{		catn("*****This is the haploid phase*****");

		// checking certain tagged sperms and their genetic polymorphism
		//select = p2.subsetIndividuals(sex="M", tag=1);
		//catn(c("Tag 1 size:", size(select)));
		//catn(c("Tag 1 polymorphism:", ifelse(size(select) == 20, sum(c(select.genomes.countOfMutationsOfType(m1), select.genomes.countOfMutationsOfType(m2)))/size(select), 0.0)));

		// output the selected sperm pop to a genome fasta file
		count = SpermPopSeqFastaCount;
		while (count > 0)
		{
			do { select_p = sample(sim.subpopulations, 1); }
			while (select_p.id == 1 | select_p.id == 2);
		
			for (ind in select_p.individuals)
			{
				writeFile("~/Desktop/tmp/"+simID+".gen"+sim.generation+".p"+select_p.id+".fa", c(">"+ind.index+".g1", ind.genome1.nucleotides()), append = T);
			}
			count = count - 1;
		}
		
		// here we can do some quick analyses of each within-ejaculate sperm subpopulation, then remove it
		for (pop in sim.subpopulations)
		{
			if (pop.id != 1 & pop.id != 2)
			{
				catn(c("p"+pop.id, "tag"+pop.tag, "sperms heterozygosity:", subpopHeterozygosity(pop, mc*4), ifelse(sum(pop.genomes.countOfMutationsOfType(m2))==0, "m1", "m2-"+sum(pop.genomes.countOfMutationsOfType(m2)))));
				pop.removeSubpopulation();
			}
		}
		
		sperms = p2.subsetIndividuals(sex="M");		// purge p1 (diploid individuals) for strict non-overlaping generations		p1.fitnessScaling = 0.0;
		// no mutation is allowed during fertilization		sim.chromosome.setHotspotMap(0.0);
		// introduce non-neutral mutations at haploid level
		if (SC == "h" | SC == "b")
		{
			if (sim.generation == 20000)
			{
				if (ST == "b" | ST == "d")
				{
					// select all tag1 sperms for non-neutral selection
					mutant = p2.subsetIndividuals(sex="M", tag=1);
					mutant.genomes.addNewDrawnMutation(m2, 1000, nucleotide = 0);
					catn(c(sim.generation, "early(): introducing non-neutral mutations to ", size(mutant), " sperms and ", size(mutant.genomes), " haploid genomes"));
				}
			}
		}
		// check the existence of non neutral mutations
		sperm_nonNeu_mut = sperms.genomes.mutationsOfType(m2);
		eggs = p2.subsetIndividuals(sex="F");
		egg_nonNeu_mut = eggs.genomes.mutationsOfType(m2);
		if (sum(p2.genomes.countOfMutationsOfType(m2)) != 0)
		{
			catn(c("# Non-neutral mutations profile:"));
			catn(c("Sperm: position(s) -", unique(sperm_nonNeu_mut.position), ", count -", size(sperm_nonNeu_mut), ", prevalence -", size(sperm_nonNeu_mut) / size(sperms)));
			catn(c("Egg: position(s) -", unique(egg_nonNeu_mut.position), ", count -", size(egg_nonNeu_mut), ", prevalence -", size(egg_nonNeu_mut) / size(eggs)));
		}
	}	else	{		catn("*****This is the diploid phase*****");
		males = p1.subsetIndividuals(sex="M");		p2.fitnessScaling = 0.0;	// purge p2 (haploid individuals)		p1.fitnessScaling = K / p1.individualCount;		sim.chromosome.setHotspotMap(MU);	
		// introduce non-neutral mutations at diploid level (need to check: now assume this happen after the
		// p1.fitnessScaling)
		if (SC == "d" | SC == "b")
		{
			if (sim.generation == 20001)
			{
				if (ST == "b" | ST == "d")
				{
					mutant = sample(p1.individuals.genomes, asInteger(size(p1.individuals.genomes) / 1000));	// ~0.1% mutant
					mutant.addNewDrawnMutation(m2, 1000);
					catn(c(sim.generation, "early(): introducing non neutral mutations"));
				}
			}
		}		// check the existence of non neutral mutations
		male_nonNeu_mut = males.genomes.mutationsOfType(m2);
		females = p1.subsetIndividuals(sex="F");
		female_nonNeu_mut = females.genomes.mutationsOfType(m2);
		if (sum(p1.genomes.countOfMutationsOfType(m2)) != 0)
		{
			catn(c("# Non-neutral mutations profile:"));
			catn(c("Male: position(s) -", unique(male_nonNeu_mut.position), ", count -", size(male_nonNeu_mut), ", prevalence -", size(male_nonNeu_mut) / size(males.genomes)));
			catn(c("Female: position(s) -", unique(female_nonNeu_mut.position), ", count -", size(female_nonNeu_mut), ", prevalence -", size(female_nonNeu_mut) / size(females.genomes)));
		}	}}20000:20009 late(){	if (sim.generation % 2 == 0)	{		sperms = p2.subsetIndividuals(sex="M");
		eggs = p2.subsetIndividuals(sex="F");		catn(c(sim.generation, "late(): total", size(sperms), "sperms"));
		catn(c(sim.generation, "late(): total", size(eggs), "eggs"));		sperms.color = ifelse(sperms.tag == 1, "red", "blue");
	}	else	{		males = p1.subsetIndividuals(sex="M");
		females = p1.subsetIndividuals(sex="F");		catn(c(sim.generation, "late(): total", size(males), "males"));
		catn(c(sim.generation, "late(): total", size(females), "females"));		males.color = ifelse(males.tag != 0, "red", "blue");
		
		for (n in 3:(males.length()+2)) { sim.addSubpop("p"+n, 0); }	// recreate within-ejaculate sperms populations
		sim.setValue("counter", 3);												// reset the counter
	}}20009 late(){	sim.simulationFinished();}