// Alternation of generations recipe//// Ben Haller, 9 November 2018// The idea, thanks to Ding He, is to model diploid individuals and haploid gametes// alternately, using addRecombinant() to generate them with the additional control// it provides.  We will have to generate our own recombination breakpoints; this// is something that could perhaps be facilitated by a new method on Chromosome.// We will keep adults in one subpop and gametes in another, to simplify the book-// keeping.// This is a sexual model at the diploid stage, and "M" also represents sperm and// "F" eggs; that could be removed, for a model of hermaphroditic gametesinitialize(){	defineConstant("K", 500);		// carrying capacity (diploid)	defineConstant("MU", 1e-7);	// mutation rate	defineConstant("R", 1e-7);		// recombination rate	defineConstant("L1", 1e6-1);	// chromosome last position (length - 1)	defineConstant("MeioC", 5);	// meiosis count per diploid
		initializeSLiMModelType("nonWF");	initializeSex("A");	initializeMutationRate(MU);	initializeMutationType("m1", 0.5, "f", 0.0);	initializeGenomicElementType("g1", m1, 1.0);	initializeGenomicElement(g1, 0, L1);	initializeRecombinationRate(R);}// Burn-in period
1 early() 
{ 
	sim.addSubpop("p1", K);		// start p1 with K diploid adults
	sim.addSubpop("p2", 0);		// start p2 with 0 haploid gametes
}
// p1, diploid individuals, reproduces by generating haploid gametes into p230001 reproduction(p1){	// for simplicity we'll just have each diploid undergo meiosis five times;	// this could depend on genetics, or be drawn from a Poisson, or whatever	// since every egg in this model reproduces, this is the female litter size,	// so it should be >= 2 to ensure population viability	for (meiosisCount in 1:MeioC)	{		// we're modeling alternation of generations in ferns, which just release		// gametes into their environment; there is no "mate choice" at the		// diploid stage, so we just generate gametes from the focal individual		if (individual.sex == "M")		{			// a male will generate four sperm per meiosis (two unrelated symmetric pairs)			break_count = rpois(1, R * L1);			breaks = rdunif(break_count, 1, L1);  // do we need to consider that breaks won't happen at the beginning/end of the chromosome?						sperm1 = p2.addRecombinant(genome1, genome2, breaks, NULL, NULL, NULL, "M");			sperm2 = p2.addRecombinant(genome2, genome1, breaks, NULL, NULL, NULL, "M");						break_count = rpois(1, R * L1);			breaks = rdunif(break_count, 1, L1);						sperm3 = p2.addRecombinant(genome1, genome2, breaks, NULL, NULL, NULL, "M");			sperm4 = p2.addRecombinant(genome2, genome1, breaks, NULL, NULL, NULL, "M");
			
			catn(c("sp1: ", sperm1.genome1.mutations.position));			catn(c("sp2: ", sperm2.genome1.mutations.position));
			catn(c("sp3: ", sperm3.genome1.mutations.position));
			catn(c("sp4: ", sperm4.genome1.mutations.position));
		}		else if (individual.sex == "F")		{			// a female will generate one egg per meiosis (and three polar bodies)			break_count = rpois(1, R * L1);			breaks = rdunif(break_count, 1, L1);						// make the egg by recombination, with a random initial strand			if (runif(1) <= 0.5)				egg = p2.addRecombinant(genome1, genome2, breaks, NULL, NULL, NULL, "F");			else				egg = p2.addRecombinant(genome2, genome1, breaks, NULL, NULL, NULL, "F");		}	}}// p2, haploid gametes, reproduces by generating diploid zygotes into p130001 reproduction(p2, "F"){	// each egg chooses a random sperm as a "mate"; we mark sperm as used in a	// fertilization by tagging them, so each one gets just one fertilization	mate = p2.sampleIndividuals(1, sex="M", tag=0);		// mark the sperm in question as used, so it can't be chosen again	mate.tag = 1;		// generate the child from the two haploid gametes; here we allow SLiM to	// choose the sex of the zygote randomly, since we're not modeling the X/Y	// note that we turned off mutation beforehand, so there shouldn't be any	child = p1.addRecombinant(individual.genome1, NULL, NULL, mate.genome1, NULL, NULL);}30001 early(){	// after reproduction, whichever population just reproduced dies off; we	// are modeling strict alternation of generations with no overlap, although	// it would not be hard to change that if we wanted to	if (sim.generation % 2 == 0)	{		// we just generated haploids; purge the diploids		p1.fitnessScaling = 0.0;				// the new haploids will be reproducing soon; reset their "used" tags		p2.individuals.tag = 0;				// we do not want mutation be involved in fertilization (for now), so turn it off		sim.chromosome.setMutationRate(0.0);	}	else	{		// we just generated diploids; purge the haploids		p2.fitnessScaling = 0.0;				// we have density-dependent population regulation in the diploid stage		p1.fitnessScaling = K / p1.individualCount;				// we want mutation during meiosis, so turn it on		sim.chromosome.setMutationRate(MU);	}}30005 late(){	// output and finish	sim.simulationFinished();}