// Keywords: alternation of generations, sporophyte, gametophyte, sperm, eggs, diploid, haploid, mating system, fertilization, meiosisinitialize(){	if (exists("slimgui"))
	{
		defineConstant("K", 500);     // carrying capacity (diploid)
		defineConstant("MU", 1e-7);   // mutation rate
		defineConstant("R", 1e-6);    // recombination rate
		defineConstant("L1", 1e6-1);  // chromosome end (length - 1)
		defineConstant("out_file", "~/Desktop/tmp/slimout");	// output file name
		defineConstant("mc", 5);		// meiosis count per diploid individual
		defineConstant("ST", "b");	// non neutral selection type: (b)enefiical, (d)eleterious
		defineConstant("SC", "d");	// non neutral selection scenario: (h)aploid-only, (d)iploid-only, (b)oth
	} else {
		if (!exists("K")) defineConstant("K", 500);
		if (!exists("mc")) defineConstant("mc", 250);
		if (!exists("MU")) defineConstant("MU", 1e-7);
		if (!exists("R")) defineConstant("R", 1e-6);
		if (!exists("L1")) defineConstant("L1", 1e6-1);
		if (!exists("ST")) defineConstant("ST", "b");
		if (!exists("SC")) defineConstant("SC", "d");
	}		initializeSLiMModelType("nonWF");	initializeSex("A");	initializeMutationRate(MU);	initializeMutationType("m1", 0.5, "f", 0.0);		// neutral	m1.convertToSubstitution = T;
	// determine non-neutral selection scenarios
	if (ST == "b") {		catn("***Non-neutral selection after burn-in: beneficial***");
		initializeMutationType("m2", 1.0, "f", 0.5);		// full dominant (h=1.0) beneficial (s=0.5)
		m1.convertToSubstitution = T;
	} else if (ST == "d") {
		catn("***Non-neutral selection after burn-in: deleterious***");
		initializeMutationType("m2", 1.0, "f", -0.5);	// full dominant (h=1.0) deleterious (s=-0.5)
		m1.convertToSubstitution = T;
	}
	
	initializeGenomicElementType("g1", m1, 1.0);	initializeGenomicElement(g1, 0, L1);	initializeRecombinationRate(R);}1:19999 reproduction(p1){	// generate K offspring with randomly chosen parents	for (i in seqLen(K))	{		Father = subpop.sampleIndividuals(1, sex="M");		Mother = subpop.sampleIndividuals(1, sex="F");		child = subpop.addCrossed(Mother, Father);	}		// done generating all offsprings, don't call us again this generation	self.active = 0;}1 early(){	defineConstant("simID", getSeed());	sim.addSubpop("p1", K);	sim.addSubpop("p2", 0);}1:19999 early(){	// non-overlapping generations	inds = p1.individuals;	adults = inds[inds.age > 0];	adults.fitnessScaling = 0.0;}19999 late(){				// all males get a non-zero unique tag value
	males = p1.subsetIndividuals(sex="M");	males.tag = 1:males.length();
			catn("*****Burn-in complete*****\n");}20000:20010 reproduction(p1){	// The ind record line: Male or Sperm|Tag|Sim_gen|Male genone1 or genone2; Sperm 1-4|Breakpoints|(B)enficial
	// mut/(D)eleterious mut positions|All mut positions
	g_1 = genome1;
	g_1_mut_pos = paste(g_1.mutations.position);
	g_1_nonNeu_mut_pos = ifelse(ST == "b", paste(c("B", g_1.positionsOfMutationsOfType(m2))), paste(c("D", g_1.positionsOfMutationsOfType(m2))));	g_2 = genome2;
	g_2_mut_pos = paste(g_2.mutations.position);
	g_2_nonNeu_mut_pos = ifelse(ST == "b", paste(c("B", g_2.positionsOfMutationsOfType(m2))), paste(c("D", g_2.positionsOfMutationsOfType(m2))));
	
	if (individual.sex == "M")
	{
		male_g1_record = paste(c("M", individual.tag, sim.generation, "1", "0", g_1_nonNeu_mut_pos, g_1_mut_pos), sep = "|");
		writeFile(out_file+"_"+simID, male_g1_record, append = T);
		male_g2_record = paste(c("M", individual.tag, sim.generation, "2", "0", g_2_nonNeu_mut_pos, g_2_mut_pos), sep = "|");
		writeFile(out_file+"_"+simID, male_g2_record, append = T);
	}		for (meiosisCount in 1:mc)	{		if (individual.sex == "M")		{			breaks = sim.chromosome.drawBreakpoints(individual);			s_1 = p2.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "M");
			s_2 = p2.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "M");
			s_1_mut_pos = paste(s_1.genome1.mutations.position);
			s_1_nonNeu_mut_pos = ifelse(ST == "b", paste(c("B", s_1.genome1.positionsOfMutationsOfType(m2))), paste(c("D", s_1.genome1.positionsOfMutationsOfType(m2))));
			s_2_mut_pos = paste(s_2.genome1.mutations.position);
			s_2_nonNeu_mut_pos = ifelse(ST == "b", paste(c("B", s_2.genome1.positionsOfMutationsOfType(m2))), paste(c("D", s_2.genome1.positionsOfMutationsOfType(m2))));			s1_record = paste(c("S", individual.tag, sim.generation, "1", breaks, s_1_nonNeu_mut_pos, s_1_mut_pos), sep = "|");
			writeFile(out_file+"_"+simID, s1_record, append = T);
			s2_record = paste(c("S", individual.tag, sim.generation, "2", breaks, s_2_nonNeu_mut_pos, s_2_mut_pos), sep = "|");
			writeFile(out_file+"_"+simID, s2_record, append = T);
						breaks = sim.chromosome.drawBreakpoints(individual);			s_3 = p2.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "M");			s_4 = p2.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "M");
			s_3_mut_pos = paste(s_3.genome1.mutations.position);
			s_3_nonNeu_mut_pos = ifelse(ST == "b", paste(c("B", s_3.genome1.positionsOfMutationsOfType(m2))), paste(c("D", s_3.genome1.positionsOfMutationsOfType(m2))));
			s_4_mut_pos = paste(s_4.genome1.mutations.position);
			s_4_nonNeu_mut_pos = ifelse(ST == "b", paste(c("B", s_4.genome1.positionsOfMutationsOfType(m2))), paste(c("D", s_4.genome1.positionsOfMutationsOfType(m2))));			s3_record = paste(c("S", individual.tag, sim.generation, "3", breaks, s_3_nonNeu_mut_pos, s_3_mut_pos), sep = "|");
			writeFile(out_file+"_"+simID, s3_record, append = T);
			s4_record = paste(c("S", individual.tag, sim.generation, "4", breaks, s_4_nonNeu_mut_pos, s_4_mut_pos), sep = "|");
			writeFile(out_file+"_"+simID, s4_record, append = T);
			// within-ejaculate sperms inherit the tag from their father			c(s_1, s_2, s_3, s_4).tag = individual.tag;				}		else if (individual.sex == "F")		{			breaks = sim.chromosome.drawBreakpoints(individual);			if (runif(1) <= 0.5)
			{				e = p2.addRecombinant(g_1, g_2, breaks, NULL, NULL, NULL, "F");
			}			else
			{				e = p2.addRecombinant(g_2, g_1, breaks, NULL, NULL, NULL, "F");
			}		}	}}20000:20010 reproduction(p2, "F"){	// initially, all sperms will have inherited tags of 1:pop_size; we will switch them to 0	// when they get used to fertilize an egg, so that they are only used once	do { mate = p2.sampleIndividuals(1, sex="M"); } while (mate.tag == 0);	// the offspring is tagged inherited from the paternal lineage	child = p1.addRecombinant(individual.genome1, NULL, NULL, mate.genome1, NULL, NULL);	child.tag = mate.tag;	
	// tag 0 for used sperms	mate.tag = 0;}// the addition of non-neutral mutations should be done in an early() event so 
// it happens prior to fitness evaluation20000:20010 early(){	if (sim.generation % 2 == 0)	{		catn("*****This is the haploid phase*****");
		sperms = p2.subsetIndividuals(sex="M");		// purge p1 (diploid individuals) for strict non-overlaping generations		p1.fitnessScaling = 0.0;		sim.chromosome.setMutationRate(0.0);
		// introduce non-neutral mutations at haploid level
		if (SC == "h" | SC == "b")
		{
			if (sim.generation == 20000)
			{
				if (ST == "b" | ST == "d")
				{
					mutant = sample(p2.individuals.genomes, asInteger(size(p2.individuals.genomes) / 1000));	// ~0.1% mutant
					mutant.addNewDrawnMutation(m2, 100000);
					catn(c(sim.generation, "early(): introducing non-neutral mutations"));
				}
			}
		}
		// check the existence of non neutral mutations
		sperm_nonNeu_mut = sperms.genomes.mutationsOfType(m2);
		eggs = p2.subsetIndividuals(sex="F");
		egg_nonNeu_mut = eggs.genomes.mutationsOfType(m2);
		if (sum(p2.genomes.countOfMutationsOfType(m2)) != 0)
		{
			catn(c("# Non-neutral mutations profile:"));
			catn(c("Sperm: position(s) -", unique(sperm_nonNeu_mut.position), ", count -", size(sperm_nonNeu_mut), ", prevalence -", size(sperm_nonNeu_mut) / size(sperms)));
			catn(c("Egg: position(s) -", unique(egg_nonNeu_mut.position), ", count -", size(egg_nonNeu_mut), ", prevalence -", size(egg_nonNeu_mut) / size(eggs)));
		}	}	else	{		catn("*****This is the diploid phase*****");
		males = p1.subsetIndividuals(sex="M");		p2.fitnessScaling = 0.0;	// purge p2 (haploid individuals)		p1.fitnessScaling = K / p1.individualCount;		sim.chromosome.setMutationRate(MU);	
		// introduce non-neutral mutations at diploid level (need to check: now assume this happen after the
		// p1.fitnessScaling)
		if (SC == "d" | SC == "b")
		{
			if (sim.generation == 20001)
			{
				if (ST == "b" | ST == "d")
				{
					mutant = sample(p1.individuals.genomes, asInteger(size(p1.individuals.genomes) / 1000));	// ~0.1% mutant
					mutant.addNewDrawnMutation(m2, 100000);
					catn(c(sim.generation, "early(): introducing non neutral mutations"));
				}
			}
		}		// check the existence of non neutral mutations
		male_nonNeu_mut = males.genomes.mutationsOfType(m2);
		females = p1.subsetIndividuals(sex="F");
		female_nonNeu_mut = females.genomes.mutationsOfType(m2);
		if (sum(p1.genomes.countOfMutationsOfType(m2)) != 0)
		{
			catn(c("# Non-neutral mutations profile:"));
			catn(c("Male: position(s) -", unique(male_nonNeu_mut.position), ", count -", size(male_nonNeu_mut), ", prevalence -", size(male_nonNeu_mut) / size(males.genomes)));
			catn(c("Female: position(s) -", unique(female_nonNeu_mut.position), ", count -", size(female_nonNeu_mut), ", prevalence -", size(female_nonNeu_mut) / size(females.genomes)));
		}	}}20000:20010 late(){	if (sim.generation % 2 == 0)	{		sperms = p2.subsetIndividuals(sex="M");
		eggs = p2.subsetIndividuals(sex="F");		catn(c(sim.generation, "late(): total", size(sperms), "sperms"));
		catn(c(sim.generation, "late(): total", size(eggs), "eggs"));		sperms.color = ifelse(sperms.tag == 1, "red", "blue");
	}	else	{		males = p1.subsetIndividuals(sex="M");
		females = p1.subsetIndividuals(sex="F");		catn(c(sim.generation, "late(): total", size(males), "males"));
		catn(c(sim.generation, "late(): total", size(females), "females"));		males.color = ifelse(males.tag != 0, "red", "blue");
	}}20010 late(){	sim.simulationFinished();}